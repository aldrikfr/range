<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Range (range.Range)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">range</a> &#x00BB; Range</nav><h1>Module <code>Range</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dt class="spec type" id="type-elt"><a href="#type-elt" class="anchor"></a><code><span class="keyword">type</span> elt</code><code> = Base.int</code></dt><dd><p>t type correspond to an integer range value</p></dd></dl><div class="spec module" id="module-Number"><a href="#module-Number" class="anchor"></a><code><span class="keyword">module</span> <a href="Number/index.html">Number</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><aside><p>'a number type is an integer with constraints *</p></aside><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> Base.Equal.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html">Range</a>.t := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <span><a href="index.html#type-t">t</a> Base.Equal.equal</span></code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> Base.Stringable.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html">Range</a>.t := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-from"><a href="#val-from" class="anchor"></a><code><span class="keyword">val</span> from : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>from start_value stop_value : will create a t value representing the range described by the two values given in parameter.</p><dl><dt>parameter start</dt><dd><p>Integer representating the starting value of the range</p></dd></dl><dl><dt>parameter stop</dt><dd><p>Integer representing the last value of the range</p></dd></dl><dl><dt>returns</dt><dd><p>Range.t type which value defined by start and stop parameters</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(<a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> Base.bool)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>filter f range : will create a new Range.t value using predicate function f. This modifies the behaviour of iter or fold function in order to apply only to values that satisfies the predicate.</p><dl><dt>parameter ~f</dt><dd><p>the predicate is attached to the range value, the predicate must respect the signature int -&gt; bool</p></dd></dl><dl><dt>parameter range</dt><dd><p>range to be filtered, if the range provided has already a filter, the new range value will merge the two filters.</p></dd></dl><dl><dt>returns</dt><dd><p>new Range.t value with a new filter added.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-reset"><a href="#val-reset" class="anchor"></a><code><span class="keyword">val</span> reset : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>remove all map and filter effects from a range.</p><dl><dt>parameter old</dt><dd><p>Range.t value</p></dd></dl><dl><dt>returns</dt><dd><p>new Range.t value from parameter without modifiers.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-is_natural"><a href="#val-is_natural" class="anchor"></a><code><span class="keyword">val</span> is_natural : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Base.bool</code></dt><dd><p>is filtered predicate</p><p>test if a Range.t value contain a filter or map function transforming data.</p><dl><dt>parameter Range.t</dt><dd><p>value to test</p></dd></dl><dl><dt>returns</dt><dd><p>test true if there is a filter false otherwise</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Base.Int.t</code></dt><dd><p>length range_value : return the number of elements contained in rang_value</p><dl><dt>parameter range_value</dt><dd><p>: range_value of type t</p></dd></dl><dl><dt>returns</dt><dd><p>Int.t with the number of elements</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>fold the equivalent of List.fold_left applied to integer range_record explore all the values contained in the range value applying f to the accumulator and the current element read by fold. If a filter was associated to the range value, only element validated by the predicate f will be passed to the function.</p><dl><dt>parameter f</dt><dd><p>function aggregating the accumulator to the current value.</p></dd></dl><dl><dt>parameter acc</dt><dd><p>initial value of the accumulator</p></dd></dl><dl><dt>parameter range</dt><dd><p>explored range value</p></dd></dl><dl><dt>returns</dt><dd><p>value of the accumulator after reading all elements</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_right"><a href="#val-fold_right" class="anchor"></a><code><span class="keyword">val</span> fold_right : <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>fold_right explore all the values contained in the range value, in reverse order, starting by the last value to the first one, applying f to the accumulator and the current element read by fold. If a filter was associated to the range value, only element validated by the predicate f will be passed to the function.</p><dl><dt>parameter f</dt><dd><p>function aggregating the accumulator to the current value.</p></dd></dl><dl><dt>parameter acc</dt><dd><p>initial value of the accumulator</p></dd></dl><dl><dt>parameter range</dt><dd><p>explored range value</p></dd></dl><dl><dt>returns</dt><dd><p>value of the accumulator after reading all elements</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(<a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> Base.unit)</span></span> <span>&#45;&gt;</span> Base.unit</code></dt><dd><p>iter apply a function with side effect on all values of the range. This function support filtering.</p><dl><dt>parameter f</dt><dd><p>function receiving an integer and returning unit</p></dd></dl><dl><dt>parameter range</dt><dd><p>value</p></dd></dl><dl><dt>returns</dt><dd><p>unit</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : <span><span>[ `Greater_than_zero ]</span> <a href="Number/index.html#type-t">Number.t</a></span> <span>&#45;&gt;</span> <span><span>[ `Greater_than_zero ]</span> <a href="Number/index.html#type-t">Number.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> Base.list</span></code></dt><dd><p>split a range value into a list of smaller range, useful for batching in parallel processing.</p><dl><dt>parameter minimal</dt><dd><p>size of a range</p></dd></dl><dl><dt>parameter count</dt><dd><p>number of subranges contained in the list.</p></dd></dl><dl><dt>parameter range</dt><dd><p>value to split</p></dd></dl><dl><dt>returns</dt><dd><p>list of ranges with a size of minimal or greater, the list having count elements max.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-contain"><a href="#val-contain" class="anchor"></a><code><span class="keyword">val</span> contain : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Base.bool</code></dt><dd><p>contain function to test if an integer value is contained in a Range.t values</p><dl><dt>parameter element</dt><dd><p>to be tested</p></dd></dl><dl><dt>parameter reference</dt><dd><p>range value</p></dd></dl><dl><dt>returns</dt><dd><p>true if element is contained in reference</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cross"><a href="#val-cross" class="anchor"></a><code><span class="keyword">val</span> cross : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> Base.Option.t</span></code></dt><dd><p>new Range.t value representing the common value between two Range.t values.</p><dl><dt>parameter a</dt><dd><p>Range.t value</p></dd></dl><dl><dt>parameter b</dt><dd><p>Range.t value</p></dd></dl><dl><dt>returns</dt><dd><p>option value with Range.t option type value defined by the common values, None if it is impossible to find common values.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cross_exn"><a href="#val-cross_exn" class="anchor"></a><code><span class="keyword">val</span> cross_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Same as cross function with exception for error handling.</p></dd></dl><dl><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> Base.Option.t</span></code></dt><dd><p>Join to generate a new Range.t value contained both a and b</p><dl><dt>parameter a</dt><dd><p>Range.t value</p></dd></dl><dl><dt>parameter b</dt><dd><p>Range.t value</p></dd></dl><dl><dt>returns</dt><dd><p>Range.t option value containing both a and b. If a and b are disjoint, they can't be joinded so None is returned.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-join_exn"><a href="#val-join_exn" class="anchor"></a><code><span class="keyword">val</span> join_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Same as join with exception for error handling</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(<a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a>)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>apply f to elements contained in a Range.t value</p><p>This feature used a delayed application of f. Like for filters, f is stacked on previous filter or map functions.</p><dl><dt>parameter f</dt><dd><p>function to apply to the content of a range value</p></dd></dl><dl><dt>parameter r</dt><dd><p>range to modify</p></dd></dl><dl><dt>returns</dt><dd><p>updated range</p></dd></dl></dd></dl></div></body></html>